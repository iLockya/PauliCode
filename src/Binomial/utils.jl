import Oscar: minimal_polynomial, is_primitive, order

"""
    minimal_polynomial(I, f; var = :a)

Returns the minimal polynomial of `f` over the residue field `R/I`.

# Arguments
- `I`: A zero-dimensional ideal.
- `f`: An element in the ring.

# Examples
```jldoctest
julia> R,(x,y) = polynomial_ring(GF(2), [:x,:y])
(Multivariate polynomial ring in 2 variables over GF(2), FqMPolyRingElem[x, y])
julia> I = ideal(R, [x^3+y, y^3+x])
Ideal generated by
  x^3 + y
  x + y^3
julia> minimal_polynomial(I,x)
x^9 + x
```
"""
function minimal_polynomial(I::MPolyIdeal, f; var=:a)
    @assert dim(I) == 0 "I must be a zero-dimensional ideal."
    R = base_ring(I)
    P, v = polynomial_ring(base_ring(R), [Symbol.(gens(R)); var])
    for i in 1:nvars(R)
        :($(Symbol(R[i])) = $(v[i])) |> eval
    end
    incl_map(el) = eval(Meta.parse("$(el)")) # inclusion map from R to P
    J = ideal(P, [incl_map.(gens(I)); v[end] - incl_map(f)]) 
    g = eliminate(J, gens(P)[1:end-1])[1]
    S, a = polynomial_ring(base_ring(R), var)
    eval(:($(Symbol(v[end])) = $(a)))
    return eval(Meta.parse("$(g)"))
end

# function minimal_polynomial_1(I::MPolyIdeal{T}, f::T; var = :a) where T
#     @assert dim(I) == 0 "I must be a zero-dimensional ideal."
#     R = base_ring(I)
#     K = base_ring(R)
#     A, p = quo(R, I)
#     B = monomial_basis(A)
#     n = length(B)

#     if K == QQ
#         M = QQMatrix(n,n)
#     elseif is_finite(K)
#         M = FqMatrix(zeros(K, n, n), K)
#     else
#         error("Unsupported base ring.")
#     end
#     for i in 1:n
#         fb = (f * B[i]) |> p |> simplify |> lift
#         dict = Dict(B .=> zeros(K, n))
#         for (key, val) in zip(monomials(fb), coefficients(fb))
#             dict[key] = val
#         end
#         for j in 1:n
#             M[i, j] = dict[B[j]]
#         end
#     end
#     S, _ = polynomial_ring(K, var)
#     return minpoly(S,M)
# end

"""
    invmod(f, I::Union{MPolyIdeal, MPolyQuoIdeal})

Take the inverse of `f` modulo `I`: `f̄` such that `f*f̄ = 1 mod I`. This will throw an error if `f` is not 
invertible in `R/I`.
"""
function Base.invmod(f, I::Union{MPolyIdeal, MPolyQuoIdeal})
    R = base_ring(I)
    A, p = quo(R, I)
    invf = inv(p(f))
    return R(invf)
end

function get_group_ops(I)
    op  = (f,g) -> normal_form(f*g, I)
    inv = f -> invmod(f, I) 
    return op, inv
end

function next_combination(combination, maxima)
    i = 1
    while i ≤ length(combination) 
        combination[i] < maxima[i] ? break : i += 1
    end
    combination[i] += 1

    if i==length(combination) && combination[i] == maxima[i]
        return combination
    end

    while combination[i] == maxima[i] && i < length(combination)
        combination[i] = 0
        i += 1
        combination[i] += 1
    end
    return combination
end
has_next_combination(combination, maxima) = any(combination .< (maxima.-1)) 

"""
    primitive_element(K::FqField)

Give a primitive element (multiplicative generator) of the finite field `K`.

# Examples
```jldoctest
julia> K = GF(81, "a")
Finite field of degree 4 and characteristic 3
julia> primitive_element(K)
2*a^2 + 2*a
```
"""
function primitive_element(K::FqField)
    p = characteristic(K)
    d = degree(K)
    group_order = p^d - 1
    primitive_elem = one(K)
    for (fac, pow) in factor(group_order).fac
        found = false
        while !found
            random_elem = rand(K)
            if random_elem != 0
                power = random_elem^(group_order÷fac)
                found = power != 1
                found && (primitive_elem *= random_elem^(group_order÷(fac^pow)))
            end
        end
    end
    primitive_elem
end

"""
    is_primitive(f::FqFieldElem)

Check if `f` is a primitive element of the finite field.
"""
function is_primitive(f::FqFieldElem)
    group_order = order(f.parent) - 1
    for (fac, pow) in factor(group_order).fac
        if f^(group_order÷fac) == 1
            return false
        end
    end
    return true
end

"""
    order(f::FqFieldElem)

Return the order of `f` in the multiplicative group of the finite field `K`.
"""
function order(f::FqFieldElem)
end

function extend_ring(R, indet_name)
    if R isa Field
        return polynomial_ring(R, indet_name)[1]
    end
    var_names = string.(gens(R))
    if indet_name in var_names
        while indet_name*string(i) in var_names
            i += 1
        end
        return polynomial_ring(base_ring(R), [var_names; indet_name*string(i)])[1]
    end
    return polynomial_ring(base_ring(R), [var_names; indet_name])[1]
end


function localize(I, elements)
    R = base_ring(I)
    non_invertible = []
    for element in elements
        if !is_one(I+ideal(element))
            push!(non_invertible, element)
        end
    end
    if is_empty(non_invertible)
        return R,I,elements
    end
    R_loc = extend_ring(R, "inv")
    inv = gens(R_loc)[end]
    I_loc = ideal([change_base_ring(R_loc, g) for g in gens(I)])
    non_invertible_loc = [change_base_ring(R_loc, el) for el in non_invertible]
    I_loc += ideal(prod(non_invertible_loc)*inv-1)
    elements_loc = [change_base_ring(R_loc, el) for el in elements]
    return R_loc, I_loc, elements_loc
end

function normal_form_with_transformation(f::T, I::MPolyIdeal; 
                        ordering=default_ordering(base_ring(I))) where T <: MPolyRingElem
    gb, Trans = standard_basis_with_transformation_matrix(I, ordering=ordering)
    qu, res = reduce_with_quotients(f, gb)
    M = Trans * transpose(qu)
    return res, M.entries[:]
end

function power_reduce(f::T, p::Union{Int,ZZRingElem}, IG::Oscar.IdealGens) where T <: MPolyRingElem
    gb = IG.isGB ? IG : standard_basis(ideal(IG))
    binary_form = digits(p, base = 2)
    f_pow_2 = f
    res = one(f.parent)
    for (i,b) in enumerate(digits(p, base=2))
        if b == 1
            res = reduce(res * f_pow_2, gb, complete_reduction=true)
        end
        f_pow_2 = reduce(f_pow_2^2, gb, complete_reduction=true)
    end
    return res
end

power_reduce(f::T, p::Union{Int,ZZRingElem}, I::MPolyIdeal) where T <: MPolyRingElem = power_reduce(f,p, standard_basis(I))

function power_normal_form(f::T, p::Union{Int,ZZRingElem}, I::MPolyIdeal) where T <: MPolyRingElem
    p ≤ 1 && return normal_form(f^p, I)
    binary_form = digits(p, base = 2)
    f_pow = [f]
    while length(f_pow) < length(binary_form)
        push!(f_pow, normal_form(f_pow[end]^2, I))
    end
    normal_form(dot(f_pow, binary_form), I)
end